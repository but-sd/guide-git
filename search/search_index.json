{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Syst\u00e8me de gestion de versions","text":"<p>Gr\u00e2ce \u00e0 un syst\u00e8me de gestion de version (Version Control System ou encore Source Control Management), on peut historiser le code source de nos applications. </p> <p>Mais pas uniquement, un SCM:</p> <ul> <li>permet de parall\u00e9liser plusieurs versions d\u2019une m\u00eame application</li> <li>sert de documentation sur l\u2019historique du code. Chaque nouvelle modification de code est accompagn\u00e9e d\u2019un message. Ces messages doivent \u00eatre r\u00e9dig\u00e9s avec soin et clart\u00e9</li> <li>permet de suivre pr\u00e9cis\u00e9ment l\u2019\u00e9volution du contenu des fichiers</li> <li>permet de revenir tr\u00e8s simplement en arri\u00e8re et \u00e0 n\u2019importe quel endroit de l\u2019historique</li> <li>facilite la collaboration, permet de travailler simplement \u00e0 plusieurs sur un m\u00eame projet</li> </ul> <p>Il existe deux types de SCM :</p> <ul> <li>centralis\u00e9 : un serveur central contient l\u2019historique du code et les d\u00e9veloppeurs travaillent en local sur leur machine. Ils doivent se connecter au serveur central pour r\u00e9cup\u00e9rer les derni\u00e8res modifications et pour envoyer les leurs. Exemple : SVN</li> <li>d\u00e9centralis\u00e9 : chaque d\u00e9veloppeur poss\u00e8de une copie compl\u00e8te de l\u2019historique du code sur sa machine. Il n\u2019y a pas de serveur central. Les d\u00e9veloppeurs peuvent travailler en local et envoyer leurs modifications \u00e0 d\u2019autres d\u00e9veloppeurs. Exemple : Git, Mercurial</li> </ul> <p>Actuellement, le SCM le plus utilis\u00e9 est Git. Il est d\u00e9centralis\u00e9 et tr\u00e8s performant. Il est utilis\u00e9 par de tr\u00e8s nombreux projets open source et par de tr\u00e8s nombreuses entreprises.</p> <p></p>"},{"location":"#git","title":"Git","text":"<p>Git est un logiciel de gestion de versions d\u00e9centralis\u00e9. C'est un logiciel libre cr\u00e9\u00e9 par Linus Torvalds, auteur du noyau Linux, et distribu\u00e9 selon les termes de la licence publique g\u00e9n\u00e9rale GNU version 2.</p> <p>Un d\u00e9p\u00f4t git est un dossier qui contient les fichiers du projet ainsi que les informations de versionnage. Il est possible de cr\u00e9er un d\u00e9p\u00f4t git \u00e0 partir d'un dossier existant ou de cr\u00e9er un dossier \u00e0 partir d'un d\u00e9p\u00f4t git.</p> <p>Le concept de commit est au coeur de git. Un commit est une sauvegarde de l'\u00e9tat des fichiers \u00e0 un instant donn\u00e9. Un commit repr\u00e9sente un ensemble coh\u00e9rent de modifications. </p>"},{"location":"autres-commandes/","title":"Autres commandes utiles","text":""},{"location":"autres-commandes/#blame-identifier-lauteur-dune-ligne-de-code","title":"blame - Identifier l'auteur d'une ligne de code","text":"<p>Pour identifier l'auteur d'une ligne de code, il faut ex\u00e9cuter la commande suivante : <pre><code>git blame &lt;file&gt;\n</code></pre></p> <p>Cela permet de voir qui a modifi\u00e9 une ligne de code et \u00e0 quel moment. Cela peut \u00eatre utile pour identifier l'auteur d'un bug. Dans Visual Studio Code, il est possible d'afficher les informations de git blame en survolant une ligne de code.</p> <p></p> <p>&lt;!-- ## chery-pick - Appliquer un commit sur une autre branche</p> <p>La commande <code>git cherry-pick</code> permet d'appliquer un commit d'une branche sur une autre branche. Cette commande est utile pour appliquer un commit sur une branche sans fusionner la branche. </p> <p>Le <code>cherry-pick</code> est un outil puissant mais qui peut \u00eatre dangereux. Il est donc important de bien comprendre son fonctionnement avant de l'utiliser. Elle poss\u00e8de de nombreux cas d\u2019usages : appliquer une modification commit\u00e9e sur une mauvaise branche, r\u00e9cup\u00e9rer un bugfix depuis une branche pour l\u2019appliquer \u00e0 une autre\u2026</p> <p>Pour utiliser la commande <code>git cherry-pick</code>, il faut se placer sur la branche sur laquelle on souhaite appliquer le commit. Il faut ensuite utiliser la commande <code>git cherry-pick</code> suivie du hash du commit \u00e0 appliquer.</p> <pre><code>git cherry-pick 5f4a4b2\n</code></pre> <p>Cette commande applique le commit <code>5f4a4b2</code> sur la branche courante. Le commit <code>5f4a4b2</code> n'est pas supprim\u00e9 de la branche d'origine. Il est donc possible de l'appliquer sur plusieurs branches.</p> <pre><code>gitGraph\n       commit\n       branch develop\n       commit\n       checkout main\n       commit\n       checkout develop\n       commit id:\"3-5f4a4b2\"\n       checkout main\n       commit\n       cherry-pick id:\"3-5f4a4b2\"\n       commit\n       checkout develop\n       commit\n``` --&gt;\n\n## diff - Afficher les diff\u00e9rences\n\nPour afficher les diff\u00e9rences entre l'index et le r\u00e9pertoire de travail, il faut ex\u00e9cuter la commande suivante :\n```bash\ngit diff</code></pre> <p></p> <p>Il est possible d'afficher les diff\u00e9rences entre l'index et le r\u00e9pertoire de travail pour un fichier en particulier avec la commande suivante : <pre><code>git diff &lt;file&gt;\n</code></pre></p> <p>Il est possible de voir ces diff\u00e9rences directement dans l'ide. Par exemple, avec Visual Studio Code, il suffit de cliquer sur le fichier dans l'onglet source control.</p> <p></p> <p>Pour afficher les diff\u00e9rences entre l'index et le dernier commit, il faut ex\u00e9cuter une des commandes suivantes : <pre><code>git diff --cached\ngit diff HEAD\n</code></pre></p> <p>Pour afficher les diff\u00e9rences entre deux commits, il faut ex\u00e9cuter la commande suivante : <pre><code>git diff &lt;commit1&gt; &lt;commit2&gt;\n</code></pre></p> <p>Par exemple pour afficher la diff\u00e9rence entre le dernier commit et l'avant dernier commit, il faut ex\u00e9cuter la commande suivante : <pre><code>git diff HEAD HEAD^\n</code></pre></p>"},{"location":"autres-commandes/#log-afficher-lhistorique-des-commits","title":"log - Afficher l'historique des commits","text":"<p>Pour afficher l'historique des commits, il faut ex\u00e9cuter la commande suivante : <pre><code>git log\n</code></pre></p> <p>Il est possible de filtrer l'historique des commits avec diff\u00e9rentes options. </p> <p>Par exemple, pour afficher les 3 derniers commits, on peut ex\u00e9cuter la commande suivante : <pre><code>git log -n 3\n</code></pre></p> <p></p> <p>Pour afficher les commits d'une p\u00e9riode : <pre><code>git log --since=\"2022-01-01\" --until=\"2022-12-31\"\n</code></pre></p> <p>Pour afficher les commits d'un fichier : <pre><code>git log -- &lt;file&gt;\n</code></pre></p> <p>Les options de filtrage peuvent \u00eatre combin\u00e9es. Par exemple, pour afficher les 3 derniers commits d'un utilisateur sur un fichier : <pre><code>git log --author=\"John Doe\" -n 3 -- &lt;file&gt;\n</code></pre></p>"},{"location":"autres-commandes/#reset-annuler-un-commit","title":"reset - Annuler un commit","text":"<p>Il est possible d'annuler le dernier commit avec la commande suivante : <pre><code>git reset --soft HEAD^\n</code></pre></p> <p>Si l'on souhaite annuler le dernier commit et supprimer les fichiers de l'index, il faut ex\u00e9cuter la commande suivante : <pre><code>git reset --hard HEAD^\n</code></pre></p> <p>Le caract\u00e8re ^ signifie le commit pr\u00e9c\u00e9dent. Il est possible d'annuler plusieurs commits en ajoutant plusieurs ^. Il est aussi possible d'utilis\u00e9 le charact\u00e8re ~ pour annuler plusieurs commits. Par exemple, pour annuler les 3 derniers commits, il faut ex\u00e9cuter la commande suivante : <pre><code>git reset --soft HEAD~3\n</code></pre></p>"},{"location":"autres-commandes/#revert-annuler-un-commit-publie","title":"revert - Annuler un commit publi\u00e9","text":"<p>Il est possible d'annuler un commit publi\u00e9 avec la commande suivante : <pre><code>git revert &lt;commit&gt;\n</code></pre></p>"},{"location":"autres-commandes/#stash-mettre-de-cote-des-modifications","title":"stash - Mettre de c\u00f4t\u00e9 des modifications","text":"<p>La commande <code>git stash</code> permet de sauvegarder les modifications en cours de d\u00e9veloppement. Cette commande est utile pour sauvegarder les modifications en cours de d\u00e9veloppement sans avoir \u00e0 cr\u00e9er une branche.</p> <p>Pour utiliser la commande <code>git stash</code>, il faut se placer sur la branche sur laquelle on souhaite sauvegarder les modifications. Il faut ensuite utiliser la commande <code>git stash</code>.</p> <pre><code>git stash\n</code></pre> <p>Il est possible de donner un nom \u00e0 la modification sauvegard\u00e9e en utilisant l'option <code>-m</code>, afin de pouvoir la retrouver plus facilement.</p> <pre><code>git stash -m \"Modification en cours\"\n</code></pre> <p>Cette commande sauvegarde les modifications en cours de d\u00e9veloppement. Les modifications sont sauvegard\u00e9es dans une pile. Il est possible de sauvegarder plusieurs modifications.</p> <p>Pour lister les modifications sauvegard\u00e9es, il suffit d'utiliser la commande <code>git stash list</code>.</p> <pre><code>git stash list\n</code></pre> <p>Pour appliquer une modification sauvegard\u00e9e, il suffit d'utiliser la commande <code>git stash apply</code> suivie du num\u00e9ro de la modification ou de son nom.</p> <pre><code>git stash apply stash@{0}\n\ngit stash apply \"Modification en cours\"\n</code></pre> <p>Cette commande applique la modification <code>stash@{0}</code> sur la branche courante. La modification <code>stash@{0}</code> n'est pas supprim\u00e9e. Il est donc possible de l'appliquer sur plusieurs branches.</p> <p>Pour supprimer une modification sauvegard\u00e9e, il suffit d'utiliser la commande <code>git stash drop</code> suivie du num\u00e9ro de la modification.</p> <pre><code>git stash drop stash@{0}\n</code></pre> <p>Il est aussi possible de supprimer toutes les modifications sauvegard\u00e9es en utilisant la commande <code>git stash clear</code>.</p> <pre><code>git stash clear\n</code></pre>"},{"location":"autres-commandes/#tag-marquer-un-commit","title":"tag - Marquer un commit","text":"<p>Les tags permettent de marquer un commit. Ils sont utiles pour marquer les versions d'un projet. Ils sont, par exemple, tr\u00e8s utiles pour marquer les versions de production.</p> <p>Pour cr\u00e9er un tag, il suffit d'utiliser la commande <code>git tag</code> suivie du nom du tag et du hash du commit \u00e0 marquer.</p> <pre><code>git tag v1.0.0 5f4a4b2\n</code></pre> <p>Cette commande cr\u00e9e un tag nomm\u00e9 <code>v1.0.0</code> sur le commit <code>5f4a4b2</code>.</p> <p>L'option <code>-m</code> permet de donner un nom au tag.</p> <pre><code>git tag -m \"Version 1.0.0\" v1.0.0 5f4a4b2\n</code></pre> <p>Pour lister les tags, il suffit d'utiliser la commande <code>git tag</code>.</p> <pre><code>git tag\n</code></pre> <p>Cette commande affiche la liste des tags du projet.</p> <pre><code>v1.0.0\nv1.1.0\nv2.0.0\n</code></pre> <pre><code>gitGraph\n       commit\n       commit id: \"2-5f4a4b2\" tag: \"v1.0.0\"\n       commit\n       commit tag: \"v1.1.0\"\n       commit\n       commit tag: \"v2.0.0\"\n       commit</code></pre>"},{"location":"autres-commandes/#references","title":"R\u00e9f\u00e9rences","text":"<ul> <li>Git cherry-pick</li> <li>Git stash</li> <li>Git tag</li> </ul>"},{"location":"bases/","title":"Les commandes git indispensables","text":"<p>Le cas d'usage basique de git est de modifier des fichiers en local, puis de les envoyer vers un d\u00e9p\u00f4t distant. Il est ensuite possible de r\u00e9cup\u00e9rer les modifications du d\u00e9p\u00f4t distant en local.</p> <p>Les fichiers sont modifi\u00e9s en local, puis ajout\u00e9s \u00e0 l'index avec la commande <code>git add</code>. Les fichiers de l'index sont commit\u00e9s avec la commande <code>git commit</code>. Les commits sont ensuite envoy\u00e9s vers le d\u00e9p\u00f4t distant avec la commande <code>git push</code>. Les commits du d\u00e9p\u00f4t distant sont r\u00e9cup\u00e9r\u00e9s avec la commande <code>git pull</code>.</p> <pre><code>graph LR\nA[Working Directory] --&gt; B(Git Add)\nB --&gt; C(Git Commit)\nC --&gt; D(Git Push)\nD --&gt; E(Git Pull)\nE --&gt; C\n\nstyle A fill:#0394fc\nstyle B fill:#0394fc\nstyle C fill:#0394fc\nstyle D fill:#ece6f0\nstyle E fill:#ece6f0</code></pre>"},{"location":"bases/#init-initialiser-un-depot-git","title":"init - Initialiser un d\u00e9p\u00f4t git","text":"<p>Afin d'initialiser un d\u00e9p\u00f4t git, il faut se placer dans le r\u00e9pertoire de travail et ex\u00e9cuter la commande suivante : <pre><code>git init\n</code></pre></p> <p>Cela cr\u00e9e un dossier .git qui contient les informations de versionnage. Il est possible de voir ce dossier en affichant les fichiers cach\u00e9s. Par exemple, sous Linux ou avec git-bash, il faut ex\u00e9cuter la commande suivante : <pre><code>ls -a\n</code></pre> </p> <p>Un d\u00e9p\u00f4t git est compos\u00e9 de trois zones :</p> <ul> <li>le r\u00e9pertoire de travail : c'est le dossier qui contient les fichiers du projet</li> <li>l'index : c'est la zone qui contient les fichiers qui seront commit\u00e9s</li> <li>l'historique : c'est la zone qui contient les commits</li> </ul> <p>Lors de l'initialisation d'un d\u00e9p\u00f4t git, le r\u00e9pertoire de travail et l'index sont identiques. Lorsqu'on add un fichier \u00e0 l'index, il est copi\u00e9 dans celui-ci. Lorsqu'on commit, les fichiers de l'index sont copi\u00e9s dans l'historique.</p> <p>La zone d\u2019index, nomm\u00e9e staging en anglais, est une zone temporaire dans laquelle on ajoute les fichiers qui feront partie du prochain instantan\u00e9. Dans le langage de Git, les instantan\u00e9s se nomment des commits.</p> <pre><code>graph LR\nA[R\u00e9pertoire de travail] -- git add --&gt; C(Index)\nC -- git commit --&gt; D[Historique]</code></pre> <p>Dans l'ide Visual Studio Code, les zones sont repr\u00e9sent\u00e9es dans l'onglet source control. Changes correspond au r\u00e9pertoire de travail, Staged Changes correspond \u00e0 l'index et Commits correspond \u00e0 l'historique.</p> <p></p>"},{"location":"bases/#add-ajouter-des-fichiers-a-lindex","title":"add - Ajouter des fichiers \u00e0 l'index","text":"<p>Ajoute le fichier \u00e0 l'index <pre><code>git add &lt;file&gt;\n</code></pre></p> <p>Avant l'ajout du fichier \u00e0 l'index, le fichier n'est pas pr\u00e9sent dans l'onglet Staged Changes de Visual Studio Code. Il est pr\u00e9sent dans l'onglet Changes.</p> <p></p> <p>Apr\u00e8s l'ajout du fichier \u00e0 l'index, le fichier est pr\u00e9sent dans l'onglet Staged Changes de Visual Studio Code. Il n'est plus pr\u00e9sent dans l'onglet Changes.</p> <p></p> <p>Si l'on modifie le fichier index.html, le fichier est pr\u00e9sent dans l'onglet Changes de Visual Studio Code et que l'on ajoute par exemple le fichier style.css \u00e0 l'index, les deux fichiers sont pr\u00e9sents dans l'onglet Staged Changes de Visual Studio Code.</p> <p></p> <p>Ajoute tous les fichiers du r\u00e9pertoire de travail \u00e0 l'index <pre><code>git add .\n</code></pre></p> <p></p> <p>Ajoute plusieurs fichiers \u00e0 l'index <pre><code>git add &lt;file1&gt; &lt;file2&gt;\n</code></pre></p> <p>Ajoute tous les fichiers correspondant \u00e0 un pattern \u00e0 l'index <pre><code>git add *.txt\n</code></pre></p> <p>Ici, on ajoute tous les fichiers avec l'extension .txt \u00e0 l'index.</p>"},{"location":"bases/#rm-supprimer-des-fichiers-de-lindex","title":"rm - Supprimer des fichiers de l'index","text":"<p>Efface le fichier de l'index mais pas du disque <pre><code>git rm &lt;file&gt; --cached\n</code></pre></p> <p></p> <p>Dans cet exemple, le fichier <code>do-not-commit-this-file.txt</code> a \u00e9t\u00e9 pouss\u00e9 dans l'index par erreur. Il faut donc l'enlever de l'index. Pour cela, il faut ex\u00e9cuter la commande suivante : <pre><code>git rm do-not-commit-this-file.txt --cached\n</code></pre></p> <p>Nous verrons un peu plus tard, que si l'on ne souhaite pas qu'un fichier soit versionn\u00e9, on peut l'ajouter dans le fichier .gitignore.</p> <p></p> <p>D\u00e9place/renomme le fichier dans l'index et sur le disque <pre><code>git mv &lt;old&gt; &lt;new&gt;\n</code></pre></p>"},{"location":"bases/#status-afficher-letat-des-fichiers","title":"status - Afficher l'\u00e9tat des fichiers","text":"<p>Une fois le fichier ajout\u00e9 \u00e0 l'index, il est possible de voir son \u00e9tat avec la commande suivante : <pre><code>git status\n</code></pre></p> <p></p>"},{"location":"bases/#diff-afficher-les-differences-entre-les-fichiers","title":"diff - Afficher les diff\u00e9rences entre les fichiers","text":"<p>Il est possible de voir les diff\u00e9rences entre les fichiers avec la commande suivante : <pre><code>git diff\n</code></pre></p> <p></p> <p></p>"},{"location":"bases/#commit-commiter-les-fichiers-de-lindex-dans-lhistorique","title":"commit - Commiter les fichiers de l'index dans l'historique","text":"<p>Pour commiter les fichiers de l'index, il faut ex\u00e9cuter la commande suivante : <pre><code>git commit\n</code></pre></p> <p>Cette commande ouvre un \u00e9diteur de texte pour saisir le message du commit. Il est possible de saisir le message du commit directement dans la ligne de commande avec la commande suivante : <pre><code>git commit -m \"message du commit\"\n</code></pre></p> <p></p> <p>Une fois le commit effectu\u00e9, les fichiers de l'index sont copi\u00e9s dans l'historique. L'index est vid\u00e9. Dans l'onglet Commits de Visual Studio Code, on peut voir le message du commit et les fichiers qui ont \u00e9t\u00e9 commit\u00e9s.</p> <p></p> <p>Il est possible de modifier le dernier commit avec la commande suivante : <pre><code>git commit --amend\n</code></pre></p> <p>Cette commande ouvre un \u00e9diteur de texte qui permet de modifier le message du dernier commit. En ajoutant des fichiers \u00e0 l'index avant d'ex\u00e9cuter cette commande, il est possible de modifier le contenu du dernier commit. Cette commande est utile pour corriger un message de commit ou pour ajouter des fichiers oubli\u00e9s dans le dernier commit.</p> <p></p> <p>Lorsque l'on commit il est important de respecter certaines r\u00e8gles, voir Messages de commit.</p>"},{"location":"bases/#remote-publier-un-depot-git","title":"remote - Publier un d\u00e9p\u00f4t git","text":"<p>Le travail effectu\u00e9 en local peut \u00eatre publi\u00e9 sur un d\u00e9p\u00f4t git distant. Il existe plusieurs services qui permettent d'h\u00e9berger des d\u00e9p\u00f4ts git. Les plus connus sont GitHub, GitLab et Bitbucket. Ces services permettent de publier des d\u00e9p\u00f4ts git publics ou priv\u00e9s.</p> <p>Afin de publier un d\u00e9p\u00f4t git, il faut cr\u00e9er un d\u00e9p\u00f4t sur le service d'h\u00e9bergement. Une fois le d\u00e9p\u00f4t cr\u00e9\u00e9, il faut r\u00e9cup\u00e9rer l'url du d\u00e9p\u00f4t. Il existe deux types d'url : https et ssh. L'url https est plus simple \u00e0 utiliser car elle ne n\u00e9cessite pas de configuration particuli\u00e8re. L'url ssh n\u00e9cessite de configurer une cl\u00e9 ssh sur le service d'h\u00e9bergement. L'url ssh est plus s\u00e9curis\u00e9e car elle utilise une cl\u00e9 ssh pour s'authentifier. L'url https utilise un nom d'utilisateur et un mot de passe pour s'authentifier.</p> <p></p> <p>Dans la copie d'\u00e9cran ci-dessus, une aide est affich\u00e9e et propose diff\u00e9rentes commandes pour publier un d\u00e9p\u00f4t git. Il est possible de publier un d\u00e9p\u00f4t git existant ou de cr\u00e9er un nouveau d\u00e9p\u00f4t git. Dans notre cas, nous allons publier un d\u00e9p\u00f4t git existant. Il faut donc ex\u00e9cuter la commande suivante : <pre><code>git remote add origin &lt;url&gt;\n</code></pre></p>"},{"location":"bases/#clone-recuperer-un-depot-git-distant-en-local","title":"clone - R\u00e9cup\u00e9rer un d\u00e9p\u00f4t git distant en local","text":"<p>Une fois que le d\u00e9p\u00f4t git est publi\u00e9, il est possible de le r\u00e9cup\u00e9rer en local. </p> <p></p> <p>Dans la copie d'\u00e9cran ci-dessus, une aide est affich\u00e9e et propose diff\u00e9rentes commandes pour r\u00e9cup\u00e9rer un d\u00e9p\u00f4t git. Il faut donc ex\u00e9cuter la commande suivante :</p> <pre><code>git clone &lt;url&gt;\n</code></pre>"},{"location":"bases/#push-envoyer-les-commits-vers-un-depot-git","title":"push - Envoyer les commits vers un d\u00e9p\u00f4t git","text":"<p>Pour envoyer les commits vers le d\u00e9p\u00f4t distant, il faut ex\u00e9cuter la commande suivante : <pre><code>git push -u origin main\n</code></pre></p>"},{"location":"bases/#pull-recuperer-les-commits-du-depot-distant","title":"pull - R\u00e9cup\u00e9rer les commits du d\u00e9p\u00f4t distant","text":"<p>Dans le repository local, il est possible de r\u00e9cup\u00e9rer les commits du d\u00e9p\u00f4t distant avec la commande suivante : <pre><code>git pull\n</code></pre></p>"},{"location":"bases/#gitignore-ignorer-des-fichiers","title":"gitignore - Ignorer des fichiers","text":"<p>Il est possible d'ignorer des fichiers avec le fichier .gitignore. Ce fichier contient la liste des fichiers \u00e0 ignorer. Il est possible d'ignorer des fichiers, des dossiers ou des patterns. Voici un exemple de fichier .gitignore :</p> <pre><code># Ignore les fichiers avec l'extension .env\n*.env\n\n# Ignore le dossier node_modules\nnode_modules/\n\n# Ignore les fichiers avec l'extension .log dans le dossier logs\nlogs/*.log\n</code></pre> <p>On ignore les fichiers avec l'extension .env, le dossier node_modules et les fichiers avec l'extension .log dans le dossier logs. Pour un projet node.js, il est conseill\u00e9 d'ignorer le dossier node_modules. En effet, ce dossier contient les d\u00e9pendances du projet. Il est inutile de les versionner car elles peuvent \u00eatre install\u00e9es avec la commande <code>npm install</code>.</p>"},{"location":"bases/#readmemd-documenter-un-projet","title":"README.md - Documenter un projet","text":"<p>Il est conseill\u00e9 de documenter un projet avec un fichier README.md. Ce fichier contient la documentation du projet. Il est possible d'utiliser le langage markdown pour mettre en forme le texte. Ce fichier est affich\u00e9 sur la page d'accueil du d\u00e9p\u00f4t GitHub. Il est donc important de le r\u00e9diger pour donner des informations sur le projet.</p>"},{"location":"branches/","title":"Les Branches","text":"<p>Les branches constituent un \u00e9l\u00e9ment central de Git. Elles permettent de travailler sur plusieurs versions d'un m\u00eame projet en parall\u00e8le. Elles sont, par exemple, tr\u00e8s utiles pour travailler sur des fonctionnalit\u00e9s en cours de d\u00e9veloppement sans impacter le code de production. Ceci permet aussi de d\u00e9velopper une nouvelle fonctionalit\u00e9 sur une branche d\u00e9di\u00e9e sans risquer d\u2019alt\u00e9rer le code de la branche principale, qui reste stable \u00e0 tout moment.</p> <p>Lors de la cr\u00e9ation d'une branche, celle-ci est dupliqu\u00e9e \u00e0 partir de la branche courante. Les modifications apport\u00e9es \u00e0 cette branche n'impactent pas les autres branches. Une fois les modifications termin\u00e9es, il est possible de fusionner la branche avec la branche courante.</p> <pre><code>gitGraph\n   commit\n   commit\n   branch branch1\n   commit\n   checkout main\n   branch branch2\n   commit\n   commit\n   checkout branch1\n   commit\n   checkout branch2\n   commit\n   commit\n   checkout main\n   merge branch1\n   checkout main\n   merge branch2\n   checkout main\n   commit\n   branch branch3\n   commit</code></pre>"},{"location":"branches/#lister-les-branches","title":"Lister les branches","text":"<p>Pour lister les branches d'un projet, il suffit d'utiliser la commande <code>git branch</code>.</p> <pre><code>git branch\n</code></pre> <p>Cette commande affiche la liste des branches du projet. La branche courante est indiqu\u00e9e par un ast\u00e9risque.</p> <pre><code>* main\n  branch1\n  branch2\n</code></pre> <p>L'option <code>-a</code> permet d'afficher toutes les branches du projet, y compris les branches distantes.</p> <pre><code>git branch -a\n</code></pre> <pre><code>* main\n  branch1\n  branch2\n  remotes/origin/HEAD -&gt; origin/main\n  remotes/origin/main\n  remotes/origin/branch1\n  remotes/origin/branch2\n</code></pre> <p>L'option <code>-v</code> permet d'afficher les derniers commits de chaque branche.</p> <pre><code>git branch -v\n</code></pre> <pre><code>* main   5f4a4b2 [origin/main] Update readme.md\n  branch1 5f4a4b2 Update readme.md\n  branch2 5f4a4b2 Update readme.md\n</code></pre> <p>L'option <code>--list</code> permet d'afficher les branches qui correspondent \u00e0 un motif.</p> <pre><code>git branch --list \"feat*\"\n</code></pre> <pre><code>  feature1\n  feature2\n</code></pre> <p>Enfin, quelques autres options s\u2019av\u00e8rent utiles :</p> <ul> <li><code>--contains &lt;commit&gt;</code> affiche toutes les branches contenant un commit donn\u00e9,</li> <li><code>--no-contains</code> fait le contraire de la pr\u00e9c\u00e9dente,</li> <li><code>--no-merge</code> affiche les branches qui n\u2019ont pas \u00e9t\u00e9 merg\u00e9es avec la branche courante,</li> <li><code>--merge</code> fait le contraire de la pr\u00e9c\u00e9dente.</li> </ul>"},{"location":"branches/#creer-une-branche","title":"Cr\u00e9er une branche","text":"<p>Pour cr\u00e9er une branche, il suffit d'utiliser la commande <code>git branch</code> suivie du nom de la branche \u00e0 cr\u00e9er.</p> <pre><code>git branch branch1\n</code></pre> <p>Cette commande cr\u00e9e une nouvelle branche nomm\u00e9e <code>branch1</code> \u00e0 partir de la branche courante.</p>"},{"location":"branches/#changer-de-branche","title":"Changer de branche","text":"<p>Pour changer de branche, il suffit d'utiliser la commande <code>git switch</code> suivie du nom de la branche \u00e0 utiliser.</p> <pre><code>git switch branch1\n</code></pre> <p>La branch <code>branch1</code> doit exister pour pouvoir changer de branche. Elle devient la branche courante. Il est possible de passer l'option <code>-c</code> pour cr\u00e9er une nouvelle branche et la d\u00e9finir comme branche courante.</p> <pre><code>  main\n* branch1\n  branch2\n</code></pre> <p>Cette commande permet de passer de la branche <code>main</code> \u00e0 la branche <code>branch1</code>. Il est aussi possible d'utiliser le mot cl\u00e9 <code>checkout</code> \u00e0 la place de <code>switch</code>. Le mot cl\u00e9 <code>checkout</code> est d\u00e9pr\u00e9ci\u00e9 et sera supprim\u00e9 dans une prochaine version de Git.</p> <pre><code>git checkout branch1\n</code></pre> <p>Cette commande permet de fusionner la branche <code>branch1</code> avec la branche courante. La branche <code>branch1</code> n'est pas supprim\u00e9e. </p> <p>Il est possible que la fusion de branches g\u00e9n\u00e8re des conflits. Dans ce cas, il faut r\u00e9soudre les conflits avant de pouvoir fusionner les branches. Nous verrons comment r\u00e9soudre les conflits dans un prochain chapitre.</p>"},{"location":"branches/#supprimer-une-branche","title":"Supprimer une branche","text":"<p>Pour supprimer une branche, il suffit d'utiliser la commande <code>git branch</code> suivie du nom de la branche \u00e0 supprimer et de l'option <code>-d</code>.</p> <pre><code>git branch -d branch1\n</code></pre> <p>Cette commande supprime la branche <code>branch1</code>. Il n'est pas possible de supprimer la branche courante. Il faut donc changer de branche avant de pouvoir supprimer une branche.</p>"},{"location":"branches/#renommer-une-branche","title":"Renommer une branche","text":"<p>Pour renommer une branche, il suffit d'utiliser la commande <code>git branch</code> suivie du nom de la branche \u00e0 renommer et de l'option <code>-m</code>.</p> <pre><code>git branch -m branch1 branch3\n</code></pre> <p>Cette commande renomme la branche <code>branch1</code> en <code>branch3</code>. Il n'est pas possible de renommer la branche courante. Il faut donc changer de branche avant de pouvoir renommer une branche.</p>"},{"location":"branches/#fusionner-des-branches","title":"Fusionner des branches","text":"<p>Pour fusionner des branches, il suffit d'utiliser la commande <code>git merge</code> suivie du nom de la branche \u00e0 fusionner.</p> <pre><code>git merge branch1\n</code></pre> <p>Cette commande permet de fusionner la branche <code>branch1</code> avec la branche courante. La branche <code>branch1</code> n'est pas supprim\u00e9e.</p>"},{"location":"branches/#fast-forward","title":"Fast-forward","text":"<p>Lorsque la branche courante n'a pas \u00e9t\u00e9 modifi\u00e9e depuis la cr\u00e9ation de la branche \u00e0 fusionner, la fusion est dite fast-forward. Dans ce cas, la branche courante est mise \u00e0 jour avec les modifications de la branche \u00e0 fusionner.</p> <pre><code>gitGraph\n   commit\n   commit\n   branch branch1\n   commit\n   checkout main\n   commit\n   commit\n   checkout branch1\n   commit\n   checkout main\n   merge branch1</code></pre>"},{"location":"branches/#3-way-merge","title":"3-way merge","text":"<p>Lorsque la branche courante a \u00e9t\u00e9 modifi\u00e9e depuis la cr\u00e9ation de la branche \u00e0 fusionner, la fusion est dite 3-way merge. Dans ce cas, Git cr\u00e9e un nouveau commit de fusion qui contient les modifications des deux branches.</p> <pre><code>gitGraph\n   commit\n   commit\n   branch branch1\n   commit\n   checkout main\n   commit\n   commit\n   checkout branch1\n   commit\n   checkout main\n   commit\n   merge branch1</code></pre> <p>Dans l'exemple ci-dessus, la branche <code>main</code> a \u00e9t\u00e9 modifi\u00e9e depuis la cr\u00e9ation de la branche <code>branch1</code>. La fusion de la branche <code>branch1</code> avec la branche <code>main</code> cr\u00e9e un nouveau commit de fusion qui contient les modifications des deux branches. </p> <p>La branche <code>main</code> est mise \u00e0 jour avec les modifications de la branche <code>branch1</code>. La branche <code>branch1</code> n'est pas supprim\u00e9e. </p>"},{"location":"branches/#fusion-avec-conflits","title":"Fusion avec conflits","text":"<p>Lorsque la branche courante et la branche \u00e0 fusionner ont \u00e9t\u00e9 modifi\u00e9es au m\u00eame endroit, la fusion g\u00e9n\u00e8re un conflit. Dans ce cas, il faut r\u00e9soudre le conflit avant de pouvoir fusionner les branches.</p> <p>La fusion se fait en trois \u00e9tapes :</p> <ul> <li>Git fusionne les fichiers qui n'ont pas \u00e9t\u00e9 modifi\u00e9s dans les deux branches,</li> <li>Git fusionne les fichiers qui ont \u00e9t\u00e9 modifi\u00e9s dans une seule branche,</li> <li>Git fusionne les fichiers qui ont \u00e9t\u00e9 modifi\u00e9s dans les deux branches.</li> </ul> <p>Le conflit se pr\u00e9sente sous la forme suivante :</p> <pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n&lt;h1 id=\"title\"&gt;Hello World&lt;/h1&gt;\n=======\n&lt;h1 id=\"title\"&gt;Hello World !&lt;/h1&gt;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch1\n</code></pre> <p>La partie <code>HEAD</code> correspond \u00e0 la branche courante. La partie <code>branch1</code> correspond \u00e0 la branche \u00e0 fusionner. Il faut modifier le fichier pour r\u00e9soudre le conflit. Dans l'exemple ci-dessus, il faut choisir entre <code>Hello World</code> et <code>Hello World !</code>. Une fois le conflit r\u00e9solu, il faut ajouter le fichier \u00e0 l'index et terminer la fusion.</p> <pre><code>git add index.html\ngit merge --continue\n</code></pre>"},{"location":"branches/#comparer-des-branches","title":"Comparer des branches","text":"<p>Pour comparer des branches, il suffit d'utiliser la commande <code>git diff</code> suivie du nom de la branche \u00e0 comparer.</p> <pre><code>git diff branch1\n</code></pre> <p>Cette commande affiche les diff\u00e9rences entre la branche courante et la branche <code>branch1</code>. Il est aussi possible de comparer deux branches entre elles.</p> <pre><code>git diff branch1 branch2\n</code></pre> <p>Cette commande affiche les diff\u00e9rences entre la branche <code>branch1</code> et la branche <code>branch2</code>.</p>"},{"location":"configurer-git/","title":"Configurer git","text":""},{"location":"configurer-git/#installer-git","title":"Installer git","text":"<p>Afin de v\u00e9rifier si git est install\u00e9, il faut ex\u00e9cuter la commande suivante : <pre><code>git --version\n</code></pre></p> <p></p> <p>Si git est install\u00e9, la commande affiche la version de git. Sinon, il faut installer git. Pour cela, il suffit de suivre les instructions du site officiel.</p>"},{"location":"configurer-git/#configurer-son-nom-et-son-email","title":"Configurer son nom et son email","text":"<p>Avant de commencer \u00e0 utiliser git, il faut configurer son nom et son email. C'est ce nom et cet email qui seront utilis\u00e9s pour les commits et qui permettront d'identifier les auteurs des modifications.</p> <p>On passe ici le flag --global, pour dire \u00e0 Git que l\u2019on d\u00e9finit la configuration globale pour l\u2019utilisateur courant. Si vous souhaitez d\u00e9finir une configuration sp\u00e9cifique \u00e0 un projet, il suffit de ne pas passer le flag --global et de vous placer dans le dossier du projet.</p> <pre><code>git config --global user.name \"John Doe\"\ngit config --global user.email johndoe@example.com\n</code></pre>"},{"location":"configurer-git/#configurer-le-proxy","title":"Configurer le proxy","text":"<p>Si vous \u00eates derri\u00e8re un proxy, il faut configurer git pour qu'il utilise le proxy. Pour cela, il faut ex\u00e9cuter la commande suivante :</p> <pre><code>git config --global http.proxy http://&lt;proxy&gt;:&lt;port&gt;\n</code></pre> <p>Par exemple, si le proxy est <pre><code>proxy.iutn.univ-poitiers\n</code></pre> et le port <pre><code>3128\n</code></pre> il faut ex\u00e9cuter la commande suivante : <pre><code>git config --global http.proxy http://proxy.iutn.univ-poitiers.fr:3128\n</code></pre></p>"},{"location":"configurer-git/#configurer-son-editeur-de-texte","title":"Configurer son \u00e9diteur de texte","text":"<p>Il est possible de configurer son \u00e9diteur de texte. Par d\u00e9faut, git utilise vim. Il est possible de configurer git pour qu'il utilise un autre \u00e9diteur de texte. Par exemple, pour utiliser Visual Studio Code, il faut ex\u00e9cuter la commande suivante :</p> <pre><code>git config --global core.editor \"code --wait\"\n</code></pre>"},{"location":"configurer-git/#consulter-la-configuration","title":"Consulter la configuration","text":"<pre><code>git config  --global --list\n</code></pre> <p>Cela vous permettra de conna\u00eetre la strat\u00e9gie utilis\u00e9e par Git pour la gestion des mots de passe, le param\u00e8tre s\u2019appelle credential.helper. Sur un poste Windows, vous verrez peut-\u00eatre wincred, qui est un utilitaire qui permet de stocker les mots de passe dans le gestionnaire de mots de passe de Windows.</p> <p>Il est possible de voir la configuration du d\u00e9p\u00f4t en ex\u00e9cutant la commande suivante :</p> <pre><code>git config --list\n</code></pre>"},{"location":"configurer-git/#laide-de-git","title":"L'aide de git","text":"<p>Il est possible d'obtenir de l'aide sur une commande git en ex\u00e9cutant la commande suivante :</p> <pre><code>git help &lt;command&gt;\n</code></pre> <p>Par exemple, pour obtenir de l'aide sur la commande status, il faut ex\u00e9cuter la commande suivante :</p> <pre><code>git help status\n</code></pre> <p></p> <p>La commande help affiche les informations suivantes :</p> <ul> <li>NAME : le nom de la commande</li> <li>SYNOPSIS : la syntaxe de la commande</li> <li>DESCRIPTION : la description de la commande</li> <li>OPTIONS : les options de la commande</li> <li>EXAMPLES : des exemples d'utilisation de la commande</li> <li>SEE ALSO : les commandes similaires</li> </ul> <p>Les commandes git sont organis\u00e9es en groupes. Il est possible d'obtenir la liste des groupes en ex\u00e9cutant la commande suivante :</p> <pre><code>git help -g\n</code></pre>"},{"location":"configurer-git/#creer-un-alias","title":"Cr\u00e9er un alias","text":"<p>Il est possible de cr\u00e9er un alias pour une commande git. Ceci permet de raccourcir les commandes les plus utilis\u00e9es. Par exemple, pour cr\u00e9er un alias pour la commande status, il faut ex\u00e9cuter la commande suivante :</p> <pre><code>git config --global alias.st status\n</code></pre> <p>Il sera alors possible d'utiliser la commande suivante :</p> <pre><code>git st\n</code></pre>"},{"location":"exercices/","title":"Exercices","text":""},{"location":"exercices/#lessentiel","title":"L'essentiel","text":""},{"location":"exercices/#mettre-en-place-un-projet-git","title":"Mettre en place un projet git","text":"<ol> <li>Cr\u00e9er un nouveau projet</li> <li>Initialiser le projet avec git</li> <li>Cr\u00e9er un fichier <code>index.html</code></li> <li>Ajouter le fichier \u00e0 l'index</li> <li>Commiter le fichier avec le message <code>Add index.html</code></li> <li>Modifier le fichier <code>index.html</code></li> <li>Ajouter le fichier \u00e0 l'index</li> <li>Commiter le fichier avec le message <code>Update index.html</code></li> <li>Modifier le fichier <code>index.html</code></li> <li>Ajouter le fichier \u00e0 l'index</li> <li>Commiter le fichier avec le message <code>Update index.html</code></li> <li>Afficher l'historique des commits</li> </ol> <p>Solution</p> Cliquez ici pour voir la solution  1. Cr\u00e9er un nouveau projet  <pre><code>mkdir git-commit\ncd git-commit\n</code></pre>  2. Initialiser le projet avec git  <pre><code>git init\n</code></pre>  3. Cr\u00e9er un fichier `index.html`  <pre><code>echo \"&lt;h1&gt;Hello World&lt;/h1&gt;\" &gt; index.html\n</code></pre>  4. Ajouter le fichier \u00e0 l'index  <pre><code>git add index.html\n</code></pre>  5. Commiter le fichier avec le message `Add index.html`  <pre><code>git commit -m \"Add index.html\"\n</code></pre>  6. Modifier le fichier `index.html`  <pre><code>echo \"&lt;h1&gt;Hello World !&lt;/h1&gt;\" &gt; index.html\n</code></pre>  7. Ajouter le fichier \u00e0 l'index  <pre><code>git add index.html\n</code></pre>  8. Commiter le fichier avec le message `Update index.html`  <pre><code>git commit -m \"Update index.html\"\n</code></pre>  9. Modifier le fichier `index.html`  <pre><code>echo \"&lt;h1&gt;Hello World !&lt;/h1&gt;&lt;p&gt;This is a new paragraph&lt;/p&gt;\" &gt; index.html\n</code></pre>  10. Ajouter le fichier \u00e0 l'index  <pre><code>git add index.html\n</code></pre>  11. Commiter le fichier avec le message `Update index.html`  <pre><code>git commit -m \"Update index.html\"\n</code></pre>  12. Afficher l'historique des commits  <pre><code>git log\n</code></pre>"},{"location":"exercices/#comparer-les-fichiers","title":"Comparer les fichiers","text":"<ol> <li>Comparer le fichier <code>index.html</code> avec le dernier commit</li> <li>Comparer le fichier <code>index.html</code> avec le commit pr\u00e9c\u00e9dent</li> <li>Comparer le fichier <code>index.html</code> avec le commit pr\u00e9c\u00e9dent du commit pr\u00e9c\u00e9dent</li> <li>Comparer le fichier <code>index.html</code> avec le premier commit</li> <li>Comparer le fichier <code>index.html</code> avec un commit pr\u00e9cis</li> </ol> <p>Solution</p> Cliquez ici pour voir la solution  1. Comparer le fichier `index.html` avec le dernier commit  <pre><code>git diff HEAD index.html\n</code></pre>  2. Comparer le fichier `index.html` avec le commit pr\u00e9c\u00e9dent  <pre><code>git diff HEAD^ index.html\n</code></pre>  3. Comparer le fichier `index.html` avec le commit pr\u00e9c\u00e9dent du commit pr\u00e9c\u00e9dent  <pre><code>git diff HEAD^^ index.html\n</code></pre>  4. Comparer le fichier `index.html` avec le premier commit  <pre><code>git diff HEAD~3 index.html\n</code></pre>  5. Comparer le fichier `index.html` avec un commit pr\u00e9cis  <pre><code>git diff 5f4a4b2 index.html\n</code></pre>"},{"location":"exercices/#annuler-un-commit","title":"Annuler un commit","text":"<ol> <li>Annuler le dernier commit</li> <li>Annuler le dernier commit et supprimer les fichiers de l'index</li> <li>Annuler le dernier commit et modifier le message du commit</li> </ol> <p>Solution</p> Cliquez ici pour voir la solution  1. Annuler le dernier commit  <pre><code>git reset --soft HEAD^\n</code></pre>  2. Annuler le dernier commit et supprimer les fichiers de l'index  <pre><code>git reset --hard HEAD^\n</code></pre>  4. Annuler le dernier commit et modifier le message du commit  <pre><code>git commit --amend\n</code></pre>"},{"location":"exercices/#mettre-de-cote-des-modifications","title":"Mettre de c\u00f4t\u00e9 des modifications","text":"<ol> <li>Cr\u00e9er un fichier <code>other-file.html</code></li> <li>Ajouter le fichier \u00e0 l'index</li> <li>Mettre de c\u00f4t\u00e9 les modifications en cours, en ajoutant un message</li> <li>Modifier le fichier <code>index.html</code></li> <li>Ajouter le fichier \u00e0 l'index</li> <li>Commiter le fichier avec le message <code>Update index.html</code></li> <li>Afficher la liste des modifications mises de c\u00f4t\u00e9</li> <li>Appliquer les modifications mises de c\u00f4t\u00e9</li> <li>Supprimer les modifications mises de c\u00f4t\u00e9</li> </ol> <p>Solution</p> Cliquez ici pour voir la solution  1. Cr\u00e9er un fichier `other-file.html`  <pre><code>echo \"&lt;h1&gt;Other file&lt;/h1&gt;\" &gt; other-file.html\n</code></pre>  2. Ajouter le fichier \u00e0 l'index  <pre><code>git add other-file.html\n</code></pre>  3. Mettre de c\u00f4t\u00e9 les modifications en cours, en ajoutant un message  <pre><code>git stash save \"Add other-file.html\"\n</code></pre>  4. Modifier le fichier `index.html`  <pre><code>echo \"&lt;h1&gt;Hello World !&lt;/h1&gt;&lt;p&gt;This is a new paragraph&lt;/p&gt;&lt;p&gt;This is another paragraph&lt;/p&gt;\" &gt;&gt; index.html\n</code></pre>  5. Ajouter le fichier \u00e0 l'index  <pre><code>git add index.html\n</code></pre>  6. Commiter le fichier avec le message `Update index.html`  <pre><code>git commit -m \"Update index.html\"\n</code></pre>  7. Afficher la liste des modifications mises de c\u00f4t\u00e9  <pre><code>git stash list\n</code></pre>  8. Appliquer les modifications mises de c\u00f4t\u00e9  <pre><code>git stash apply\n</code></pre>  9. Supprimer les modifications mises de c\u00f4t\u00e9  <pre><code>git stash drop\n</code></pre>"},{"location":"exercices/#publier-un-projet-sur-github","title":"Publier un projet sur GitHub","text":"<ol> <li>Cr\u00e9er un nouveau projet sur GitHub</li> <li>Ajouter le projet local comme remote</li> <li>Publier le projet local sur GitHub</li> </ol> <p>Solution</p> Cliquez ici pour voir la solution  1. Cr\u00e9er un nouveau projet sur GitHub  <pre><code>Aller sur https://github.com et cr\u00e9er un nouveau projet.\n</code></pre>  2. Ajouter le projet local comme remote  <pre><code>git remote add origin &lt;url&gt;\n</code></pre>  3. Publier le projet local sur GitHub  <pre><code>git push -u origin main\n</code></pre>"},{"location":"exercices/#recuperer-un-projet-depuis-github","title":"R\u00e9cup\u00e9rer un projet depuis GitHub","text":"<ol> <li>R\u00e9cup\u00e9rer un projet depuis GitHub</li> </ol> <p>Solution</p> Cliquez ici pour voir la solution  1. R\u00e9cup\u00e9rer un projet depuis GitHub  <pre><code>git clone &lt;url&gt;\n</code></pre>"},{"location":"exercices/#les-branches","title":"Les branches","text":""},{"location":"exercices/#creer-une-branche","title":"Cr\u00e9er une branche","text":"<ol> <li>Cr\u00e9er une branche <code>branch1</code></li> <li>Faire un commit sur la branche <code>branch1</code></li> <li>Cr\u00e9er une branche <code>branch2</code> \u00e0 partir de la branche principale</li> <li>Faire un commit sur la branche <code>branch2</code></li> <li>Cr\u00e9er une branche <code>branch3</code> \u00e0 partir de la branche <code>branch1</code></li> <li>Faire un commit sur la branche <code>branch3</code></li> <li>Afficher la liste des branches</li> <li>Afficher l'historique des commits</li> </ol> <p>Solution</p>"},{"location":"git-flow-complet/","title":"Exemple de Git Flow complet","text":"<pre><code>\ngitGraph\n   commit\n   commit\n   branch develop\n   commit\n   branch feature1\n    commit\n    commit\n    checkout develop\n    commit\n    merge feature1\n    branch feature2\n    commit\n    commit\n    commit\n    checkout develop\n    commit\n    branch feature3\n    commit\n    checkout develop\n    branch feature4\n    commit\n    commit\n    checkout develop\n    merge feature2\n    commit\n    branch release1\n    commit\n    commit\n    commit\n    checkout develop\n    commit\n    merge release1\n    checkout main\n    merge release1\n    checkout develop\n    commit\n    checkout main\n    branch hotfix1\n    commit\n    commit\n    checkout main\n    merge hotfix1\n    checkout develop\n    commit\n    merge hotfix1</code></pre>"},{"location":"git-flow/","title":"git flow","text":"<p>Git flow est un mod\u00e8le de gestion de branches. Il permet de g\u00e9rer les branches d'un projet de mani\u00e8re structur\u00e9e. </p> <p>Pour aller plus loin, vous pouvez consulter les sites suivant:</p> <ul> <li>Tutoriel atlasian,</li> <li>A successful git branching model.</li> </ul> <p>En r\u00e9sum\u00e9, il est compos\u00e9 de deux branches principales :</p> <ul> <li><code>main</code> : branche principale du projet. Elle contient le code de production,</li> <li><code>develop</code> : branche de d\u00e9veloppement. Elle contient le code en cours de d\u00e9veloppement.</li> </ul> <p>et de branches secondaires :</p> <ul> <li><code>feature/*</code> : branches de fonctionnalit\u00e9. Elles contiennent le code d'une fonctionnalit\u00e9 en cours de d\u00e9veloppement,</li> <li><code>release/*</code> : branches de release. Elles contiennent le code en cours de pr\u00e9paration pour une release,</li> <li><code>hotfix/*</code> : branches de hotfix. Elles contiennent le code en cours de d\u00e9veloppement pour corriger un bug en production.</li> <li><code>bugfix/*</code> : branches de bugfix. Elles contiennent le code en cours de d\u00e9veloppement pour corriger un bug en cours de d\u00e9veloppement.</li> </ul>"},{"location":"git-flow/#feature","title":"feature","text":"<p>Le sch\u00e9ma ci-dessous illustre la partie feature du git flow. Les d\u00e9veloppements se font sur la branche <code>develop</code> ou via des branches <code>feature</code> cr\u00e9\u00e9es \u00e0 partir de la branche <code>develop</code> pour d\u00e9velopper des fonctionnalit\u00e9s. Une fois les fonctionnalit\u00e9s d\u00e9velopp\u00e9es, les branches <code>feature</code> sont fusionn\u00e9es avec la branche <code>develop</code>. On peut choisir d'autoriser le travail directement sur la branche <code>develop</code> sans passer par des branches <code>feature</code> ou bien l'interdire. Selon la taille du projet, il peut \u00eatre pr\u00e9f\u00e9rable d'interdire le travail directement sur la branche <code>develop</code> pour \u00e9viter les conflits.</p> <p>Il existe des solutions pour prot\u00e9ger les branches <code>develop</code> et <code>main</code> et emp\u00eacher les modifications directes sur ces branches (nous verrons comment prot\u00e9ger les branches sur github dans un prochain chapitre).</p> <pre><code>\ngitGraph\n   commit\n   commit\n   branch develop\n   commit\n   branch feature1\n    commit\n    commit\n    checkout develop\n    commit\n    merge feature1\n    branch feature2\n    commit\n    commit\n    commit\n    checkout develop\n    commit\n    branch feature3\n    commit\n    checkout develop\n    branch feature4\n    commit\n    commit\n    checkout develop\n    merge feature2\n</code></pre> <p>Dans le flow pr\u00e9sent\u00e9 ci-dessus, la <code>feature1</code> a \u00e9t\u00e9 initialiser \u00e0 partir de la brance <code>develop</code>, 2 commits ont eu lieu sur la branche <code>feature1</code> puis la branche <code>feature1</code> a \u00e9t\u00e9 fusionn\u00e9e avec la branche <code>develop</code>. </p> <p>La <code>feature2</code> a \u00e9t\u00e9 initialiser \u00e0 partir de la brance <code>develop</code>, 3 commits ont eu lieu sur la branche <code>feature2</code> puis la branche <code>feature2</code> a \u00e9t\u00e9 fusionn\u00e9e avec la branche <code>develop</code>. </p> <p>La <code>feature3</code> a \u00e9t\u00e9 initialiser \u00e0 partir de la brance <code>develop</code>, 1 commit a eu lieu sur la branche <code>feature3</code>.</p> <p>La <code>feature4</code> a \u00e9t\u00e9 initialiser \u00e0 partir de la brance <code>develop</code>, 2 commits ont eu lieu sur la branche <code>feature4</code>.</p> <p>Les branches <code>feature3</code> et <code>feature4</code> sont en cours de d\u00e9veloppement. Elles n'ont pas encore \u00e9t\u00e9 fusionn\u00e9es avec la branche <code>develop</code>. Elles peuvent encore \u00eatre modifi\u00e9es, voir supprim\u00e9es si elles ne sont pas valid\u00e9es.</p>"},{"location":"git-flow/#release","title":"release","text":"<p>Le sch\u00e9ma ci-dessous illustre la partie release du git flow. La release est une version du projet qui est pr\u00eate \u00e0 \u00eatre mise en production. </p> <p>Une release est une version du projet qui est test\u00e9e et qui est stable. On lui attribue un num\u00e9ro de version. Par exemple, la version 1.0.0. (nous verrons comment g\u00e9rer les versions dans un prochain chapitre). Les releases se font via des branches <code>release</code> cr\u00e9\u00e9es \u00e0 partir de la branche <code>develop</code> pour pr\u00e9parer une release. </p> <p>La release est une branche de pr\u00e9paration. Elle permet aussi de tester le code avant de le mettre en production. Si un bug est d\u00e9tect\u00e9, il est possible de corriger le bug sur la branche <code>release</code> et de fusionner la branche <code>release</code> avec la branche <code>develop</code>.</p> <p>Une fois la release pr\u00eate, la branche <code>release</code> est fusionn\u00e9e avec la branche <code>develop</code> et la branche <code>main</code>.</p> <pre><code>\ngitGraph\n   commit\n   commit\n   branch develop\n   commit\n   branch release1\n    commit\n    commit\n    commit\n    checkout develop\n    commit\n    merge release1\n    checkout main\n    merge release1\n    checkout develop\n    commit</code></pre>"},{"location":"git-flow/#hotfix","title":"hotfix","text":"<p>Les hotfix se font via des branches <code>hotfix</code> cr\u00e9\u00e9es \u00e0 partir de la branche <code>main</code> pour corriger un bug en production. Une fois le hotfix d\u00e9velopp\u00e9, la branche <code>hotfix</code> est fusionn\u00e9e avec la branche <code>develop</code> et la branche <code>main</code>.</p> <p>Le <code>hotfix</code> est une branche de correction. La modification doit \u00eatre cibl\u00e9e et la dur\u00e9e de vie de la branche doit \u00eatre courte. Le <code>hotfix</code> est une branche temporaire qui doit \u00eatre supprim\u00e9e une fois la correction appliqu\u00e9e. Elle doit \u00eatre fusionn\u00e9e avec la branche <code>develop</code> et la branche <code>main</code> le plus rapidement possible.</p> <pre><code>\ngitGraph\n   commit\n   commit\n   branch develop\n   commit\n   checkout main\n   branch hotfix1\n    commit\n    commit\n    checkout main\n    merge hotfix1\n    checkout develop\n    commit\n    merge hotfix1</code></pre>"},{"location":"git-flow/#bugfix","title":"bugfix","text":"<p>Les bugfix se font via des branches <code>bugfix</code> cr\u00e9\u00e9es \u00e0 partir de la branche <code>develop</code> pour corriger un bug en cours de d\u00e9veloppement. Une fois le bugfix d\u00e9velopp\u00e9, la branche <code>bugfix</code> est fusionn\u00e9e avec la branche <code>develop</code>. Il s'agit du m\u00eame principe que le <code>hotfix</code> mais pour corriger un bug en cours de d\u00e9veloppement.</p> <p>R\u00e9sum\u00e9</p> <p>Le sch\u00e9ma Git flow complet illustre le git flow complet. Les d\u00e9veloppements se font sur la branches <code>develop</code> ou via des branches <code>feature</code> cr\u00e9\u00e9es \u00e0 partir de la branche <code>develop</code> pour d\u00e9velopper des fonctionnalit\u00e9s. Une fois les fonctionnalit\u00e9s d\u00e9velopp\u00e9es, les branches <code>feature</code> sont fusionn\u00e9es avec la branche <code>develop</code>.</p> <p>Les releases se font via des branches <code>release</code> cr\u00e9\u00e9es \u00e0 partir de la branche <code>develop</code> pour pr\u00e9parer une release. Une fois la release pr\u00eate, la branche <code>release</code> est fusionn\u00e9e avec la branche <code>develop</code> et la branche <code>main</code>.</p> <p>Les hotfix se font via des branches <code>hotfix</code> cr\u00e9\u00e9es \u00e0 partir de la branche <code>main</code> pour corriger un bug en production. Une fois le hotfix d\u00e9velopp\u00e9, la branche <code>hotfix</code> est fusionn\u00e9e avec la branche <code>develop</code> et la branche <code>main</code>.</p>"},{"location":"markdown/","title":"markdown","text":"<p>Le markdown est un langage de balisage l\u00e9ger. Il permet de mettre en forme du texte avec des caract\u00e8res sp\u00e9ciaux. Il est utilis\u00e9 pour r\u00e9diger de la documentation. Il est utilis\u00e9 par de nombreux sites comme GitHub, GitLab, Stack Overflow, etc. Sur un repo github par exemple, le fichier README.md est affich\u00e9 sur la page d'accueil du repo. Ce fichier est r\u00e9dig\u00e9 en markdown. Il permet de d\u00e9crire le projet et de donner des informations sur son utilisation.</p> <p>Par exemple comment installer le projet, comment l'utiliser, etc.</p> <p>Attention toutefois, il existe des variantes du markdown. Par exemple, GitHub utilise une variante du markdown. Il est donc possible que le markdown ne soit pas interpr\u00e9t\u00e9 de la m\u00eame fa\u00e7on selon le site.</p>"},{"location":"markdown/#syntaxe","title":"Syntaxe","text":"<p>source : https://www.markdownguide.org/basic-syntax/ source : https://guides.github.com/features/mastering-markdown/</p>"},{"location":"markdown/#exercices","title":"Exercices","text":"<ul> <li>[ ] Cr\u00e9er un fichier markdown</li> <li>[ ] Ajouter un titre</li> <li>[ ] Ajouter un sous-titre</li> <li>[ ] Ajouter un paragraphe</li> <li>[ ] Ajouter une liste \u00e0 puces</li> <li>[ ] Ajouter une liste num\u00e9rot\u00e9e</li> <li>[ ] Ajouter une liste de t\u00e2ches</li> </ul>"},{"location":"messages-commit/","title":"Bien \u00e9crire ses messages de commit","text":""},{"location":"messages-commit/#pourquoi-bien-ecrire-ses-messages-de-commit","title":"Pourquoi bien \u00e9crire ses messages de commit ?","text":"<p>Les messages de commit sont importants car ils permettent de comprendre l'historique d'un projet, de savoir pourquoi une modification a \u00e9t\u00e9 faite. Ils permettent \u00e9galement de retrouver une modification en particulier.</p> <p>Afin d'avoir un message de commit clair et explicite, il est important de respecter certaines r\u00e8gles. Mais surtout il faut que les modifications soient coh\u00e9rentes et qu'elles soient petites. Il est pr\u00e9f\u00e9rable de faire plusieurs petits commits plut\u00f4t qu'un seul gros commit. Si un commit est trop gros, il est difficile de comprendre la modification et donc de l'expliquer dans le message de commit.</p> <p>Il sera aussi plus facile d'annuler un commit si celui-ci est petit. Il suffira de faire un <code>git reset HEAD~1</code> pour annuler le dernier commit. Si le commit est trop gros, il sera plus difficile de l'annuler.</p>"},{"location":"messages-commit/#les-7-regles-dor","title":"Les 7 r\u00e8gles d'or","text":"<p>source : https://chris.beams.io/posts/git-commit/</p> <p>Un message de commit doit \u00eatre court et explicite. Il doit permettre de comprendre rapidement la modification apport\u00e9e.</p> <p>1. S\u00e9parer le titre du corps par une ligne vide</p> <pre><code>Ajoute une nouvelle fonctionnalit\u00e9 au projet\n\nCe commit ajoute une nouvelle fonctionnalit\u00e9 au projet. Cette fonctionnalit\u00e9 permet de faire ceci et cela. Elle est accessible via le menu principal.\n</code></pre> <p>2. Limiter le titre \u00e0 50 caract\u00e8res</p> <p>Un titre trop long est difficile \u00e0 lire. Il est pr\u00e9f\u00e9rable de limiter le titre \u00e0 50 caract\u00e8res. La description permet de donner plus de d\u00e9tails sur la modification.</p> <p>3. Commencer le titre par une majuscule</p> <p>Mettre la premi\u00e8re lettre du titre en majuscule facilite la lecture.</p> <p>4. Ne pas terminer le titre par un point</p> <p>Le titre est une phrase courte. Il n'est pas n\u00e9cessaire de mettre un point \u00e0 la fin, sachant que l'on essaie de limiter le titre \u00e0 50 caract\u00e8res.</p> <p>5. Utiliser l'imp\u00e9ratif</p> <p>L'imp\u00e9ratif est un mode qui permet d'exprimer un ordre. Il est utilis\u00e9 pour les titres de commit car il permet de d\u00e9crire ce que fait le commit.</p> <p>6. Utiliser 72 caract\u00e8res pour le corps du message</p> <p>Le corps du message permet de donner plus de d\u00e9tails sur la modification. Il est pr\u00e9f\u00e9rable de limiter le corps du message \u00e0 72 caract\u00e8res. Cela permet de faciliter la lecture du message, notamment sur les terminaux qui ne sont pas tr\u00e8s larges. Le fait aussi de garder des caract\u00e8res pour indent\u00e9 le texte et ainsi le rendre plus lisible.</p> <p>7. D\u00e9crire dans le corps du message le pourquoi et non le comment</p> <p>Le corps du message permet de donner plus de d\u00e9tails sur la modification. Il est pr\u00e9f\u00e9rable de d\u00e9crire le pourquoi de la modification plut\u00f4t que le comment. Le comment est visible dans le code. Le pourquoi permet de comprendre la modification.</p>"},{"location":"messages-commit/#emojis","title":"Emojis","text":"<p>Il est possible d'utiliser des emojis dans les messages de commit. Cela permet de donner plus de sens au message. Il existe des extensions pour Visual Studio Code qui permettent d'ajouter des emojis dans les messages de commit. Par exemple : Gitmoji.</p> <p>Attention toutefois \u00e0 ne pas en abuser. Il faut que le message reste lisible. Il est pr\u00e9f\u00e9rable de se limiter \u00e0 un seul emoji par message. Et il faut que l'emoji soit en rapport avec la modification. Il ne faut pas mettre un emoji juste pour mettre un emoji.</p> <p>Il est aussi conseiller de limiter le nombre d'emojis utilis\u00e9s. Il est pr\u00e9f\u00e9rable d'utiliser les emojis les plus courants. </p> <p>Voici une liste d'emojis courants :</p> <ul> <li>\ud83c\udf89 <code>:tada:</code> : Ajout d'une nouvelle fonctionnalit\u00e9</li> <li>\ud83d\udc1b <code>:bug:</code> : Correction d'un bug</li> <li>\ud83d\udcdd <code>:memo:</code> : Documentation</li> <li>\ud83d\ude80 <code>:rocket:</code> : Am\u00e9lioration des performances</li> <li>\ud83d\udd16 <code>:bookmark:</code> : Versionnage</li> <li>\ud83d\udea7 <code>:construction:</code> : Travail en cours</li> <li>\ud83c\udfa8 <code>:art:</code> : Am\u00e9lioration du code</li> <li>\ud83d\ude9a <code>:truck:</code> : D\u00e9placement ou renommage de fichiers</li> <li>\ud83d\udce6 <code>:package:</code> : Mise \u00e0 jour des d\u00e9pendances</li> <li>\ud83d\ude91 <code>:ambulance:</code> : Correction d'un crash en urgence</li> <li>\u2705 <code>:white_check_mark:</code> : Ajout de tests</li> <li>\ud83d\udd12 <code>:lock:</code> : Correction d'une faille de s\u00e9curit\u00e9</li> </ul>"},{"location":"reecrire-historique/","title":"R\u00e9\u00e9crire l'historique","text":"<p>TODO</p>"},{"location":"reecrire-historique/#re-ecrire-lhistorique","title":"R\u00e9-\u00e9crire l'historique","text":"<p>Il est possible de modifier l'historique avec la commande suivante : <pre><code>git rebase -i HEAD~3\n</code></pre></p> <p>Cette commande ouvre un \u00e9diteur de texte qui permet de modifier l'historique. Il est possible de modifier le message d'un commit, de supprimer un commit ou de fusionner deux commits.</p>"},{"location":"reecrire-historique/#modifier-le-message-dun-commit","title":"Modifier le message d'un commit","text":"<p>Pour modifier le message d'un commit, il faut remplacer le mot pick par reword devant le commit.</p>"},{"location":"reecrire-historique/#supprimer-un-commit","title":"Supprimer un commit","text":"<p>Pour supprimer un commit, il faut supprimer la ligne correspondant au commit.</p>"},{"location":"reecrire-historique/#fusionner-deux-commits","title":"Fusionner deux commits","text":"<p>Pour fusionner deux commits, il faut remplacer le mot pick par squash devant le commit.</p> <p>Il est possible de fusionner plusieurs commits en ajoutant plusieurs squash devant les commits.</p> <p>Ces actions peuvent aussi \u00eatre faite directement dans l'ide, ce qui peut \u00eatre plus simple. </p> <p>Par exemple avec l'extension git lens de Visual Studio Code:</p> <p></p>"}]}